{
  "name": "forky",
  "version": "0.0.2",
  "description": "node-forky ==========",
  "main": "index.js",
  "scripts": {
    "test": "make"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/brianc/node-forky.git"
  },
  "keywords": [
    "cluster",
    "pre-fork"
  ],
  "author": {
    "name": "Brian M. Carlson"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/brianc/node-forky/issues"
  },
  "devDependencies": {
    "okay": "~0.3.0",
    "mocha": "~1.12.0",
    "express": "~3.3.4",
    "request": "~2.25.0",
    "async": "~0.2.9",
    "sliced": "0.0.5",
    "express-domain-middleware": "~0.1.0"
  },
  "readme": "node-forky\n==========\n\nForky makes using the cluster module easier without preventing you from using it directly.\n\n__Problem__: using `require('cluster')` properly is difficult, error prone, and hard to test.  \n__Solution__: \n\n\n__master.js__\n```js\nvar forky = require('forky');\nforky(__dirname + '/worker.js');\n```\n\n__worker.js__\n```js\nvar http = require('http');\nhttp.createServer(function(req, res) {\n  res.writeHead(200, {'content-type': 'text/html'});\n  res.end('Hello from worker ' + require('cluster').worker.id);\n});\n```\n\n__bash__\n```bash\n$ node master\n```\n\n##### For a more complete example please check out the [detailed example implementation](https://github.com/brianc/node-forky/tree/master/examples)\n\n## installation\n\n`npm install forky`\n\n## usage\n\nForky is meant to work with your existing http server without modifying the server.  \nTo take advantage of a multi-core system create a new file called `master.js` and require forky:\n\n__master.js__\n```js\nvar forky = require('forky');\n```\n\nOnce this file is created, call forky by passing it the file path to your existing http server or your old _entry point_ to your application.\n\n_example: if you used to type `node index.js` to start your application, your master.js file should look like this_\n\n__master.js__\n```js\nvar forky = require('forky');\nforky(__dirname + '/index.js');\n```\n\nWhat forky will do is spawn a number of workers equal to the number of cores you have available on your system.  \nIf one of these workers disconnects for __any reason__ due to a process.uncaughtException or even a `kill -9 <pid>` to the worker process, forky will spawn a new worker immedately.  \nAfter forky has spawned a new worker it will attempt to gracefully shut down your disconnecte worker.  After a timeout if your disconnected worker is still running, forky will forcefully kill it.\n\n\nThe best way to handle unexpected errors in node is to shut down your process and spawn a new one. Forky makes clean process shutdown & respawn easy as pie.\n\nLet's implement an http server in node that throws an uncatchable exception.\n\n__index.js__\n```js\nvar http = require('http');\nhttp.createServer(function(req, res) {\n  res.writeHead(200, {'content-type': 'text/html'});\n  res.end('everything is groovy');\n  setTimeout(function() {\n    throw new Error(\"This will crash your node process\");\n  }, 1000);\n});\n```\n\nNow if someone hits our server, 1 second later the server will crash. The easy __but wrong__ way to handle this is by adding a `process.on('uncaughtException')` handler and just keep going forward as if nothing has happend:\n\n__index.js__\n```js\nvar http = require('http');\nhttp.createServer(function(req, res) {\n  res.writeHead(200, {'content-type': 'text/html'});\n  res.end('everything is groovy');\n  setTimeout(function() {\n    throw new Error(\"This will crash your node process\");\n  }, 1000);\n});\n\nprocess.on('uncaughtException', function(err) {\n  //log the error\n  console.error(err);\n  //continue on as if nothing has happend...\n  //but something HAS happened.  What if the error wasn't in a timeout?\n  //what if our error came from somewhere deep down and left some dangling\n  //uncloses sockets or connections to database or open files?  We could be leaking\n  //resources slowly and not even know it. oh no!\n});\n```\n\nInstead of doing that let's use our `master.js` file we created above and modify our worker to _gracefully disconnect_ to cleanup the problems caused by the unexpected error:\n\n\n__index.js__\n```js\nvar http = require('http');\nhttp.createServer(function(req, res) {\n  res.writeHead(200, {'content-type': 'text/html'});\n  res.end('everything is groovy');\n  setTimeout(function() {\n    throw new Error(\"This will crash your node process\");\n  }, 1000);\n});\n\nprocess.on('uncaughtException', function(err) {\n  //log the error\n  console.error(err);\n  //let's tell our master we need to be disconnected\n  require('forky').disconnect();\n  //in a worker process, this will signal the master that something is wrong\n  //the master will immediately spawn a new worker\n  //and the master will disconnect our server, allowing all existing traffic to end naturally\n  //but not allowing this process to accept any new traffic\n});\n```\n\nAll of the above is to help with graceful shutdowns.  Forky doesn't actually need you to signal disconnect from your workers. You can just let the exception crash the process, you can call `process.exit()`, or do anything else you want to clean up. Once your worker closes, regardless of the reason, forky will spawn a new one.\n\n## Contributing\n\nI love contributions.  If you'd like to contribute a bug fix, send in yer pull requests!  \n\nIf you want to add a more substantial feature open an issue, and let's discuss it. We can turn that issue into a pull request and get new features added. Open Source Is Awesome. :+1:\n\nDue to the race-condition type nature of managing a cluster of workers the tests don't use a test framework, they just batter the hell out of the example server and make sure it never returns an unexpected result.  To run the tests just type `make` after cloning & doing an `npm install`\n## License\n\nCopyright (c) 2013 Brian M. Carlson\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n",
  "readmeFilename": "README.md",
  "_id": "forky@0.0.2",
  "dist": {
    "shasum": "c69f26104f005fddabfc00d7348a5356ed45012f"
  },
  "_from": "forky@0.0.2"
}
